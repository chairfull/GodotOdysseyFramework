@abstract class_name StateBase extends Node
## Handles state of world in a way where non-loaded content can be set/get.

signal paused()
signal unpaused()
@warning_ignore("unused_signal") signal event(event: Event)

var ZONE_ENTERED := Event.new({ zone=ZoneInfo, who=CharInfo })
var ZONE_EXITED := Event.new({ zone=ZoneInfo, who=CharInfo })
var QUEST_STARTED := Event.new({ quest=QuestInfo })
var QUEST_TICKED := Event.new({ quest=QuestInfo })
var QUEST_TICK_COMPLETED := Event.new({ tick=QuestTick })
var QUEST_PASSED := Event.new({ quest=QuestInfo })
var QUEST_FAILED := Event.new({ quest=QuestInfo })
var ACHIEVEMENT := Event.new({ achievement=AchievementInfo })

var TOAST := Event.new({ type=TYPE_STRING_NAME, player=TYPE_INT, text=TYPE_STRING, subtext=TYPE_STRING, data=TYPE_DICTIONARY })

@export var objects: StateObjects
var dbs: Array[Database]
var _pausers: Array[Object]

var chars: CharDB:
	get: return objects.chars
var items: ItemDB:
	get: return objects.items
var zones: ZoneDB:
	get: return objects.zones
var quests: QuestDB:
	get: return objects.quests

func _init() -> void:
	# reload() calls set_script() which triggers this _init().
	# We know we are in business once we are the generated script.
	if get_script().resource_path == "res://_state_.gd":
		_true_reload()

func _ready() -> void:
	reload()

func add_pauser(obj: Object):
	if obj in _pausers: return
	_pausers.append(obj)
	if _pausers.size() == 1:
		_pause.call_deferred()

func remove_pauser(obj: Object):
	if not obj in _pausers: return
	_pausers.erase(obj)
	if _pausers.size() == 0:
		_unpause.call_deferred()

func _pause():
	get_tree().current_scene.process_mode = Node.PROCESS_MODE_DISABLED
	Input.mouse_mode = Input.MOUSE_MODE_VISIBLE
	paused.emit()
	
func _unpause():
	get_tree().current_scene.process_mode = Node.PROCESS_MODE_INHERIT
	Input.mouse_mode = Input.MOUSE_MODE_CAPTURED
	unpaused.emit()

func reload():
	var mods := Mods.get_enabled()
	var vars := []
	var code := []
	
	var score := VarInfo.new()
	score.default = 0
	score.value = 0
	mods[0].vars._add("score", score)
	
	for mod: ModInfo in mods:
		# Compile conditions script.
		for meth_name in mod._script_exprs:
			code.append("func %s() -> void: %s" % [meth_name, mod._script_exprs[meth_name]])
		for meth_name in mod._script_conds:
			var cond := mod._script_conds[meth_name]
			if not cond: cond = "true" # TODO: Fix.
			code.append("func %s() -> bool: return %s" % [meth_name, cond])
		
		#prints(mod.mod_name, mod.mod_version, len(mod._script_exprs), len(mod._script_conds))
		
		for db_id in StateObjects.ORDER:
			var db: Database = mod[db_id]
			code.append("\n####\n## %s x%s\n####" % [db_id.to_upper(), db.size()])
			for obj in db:
				var prop_id: String = obj.id.replace("#", "__")
				if "#" in obj.id: continue
				if obj is VarInfo:
					var prop_type: String = type_string(typeof(obj.default))
					code.append("var %s: %s:\n\tget: return objects.%s[&\"%s\"].value\n\tset(v): objects.%s[&\"%s\"].value = v" % [prop_id, prop_type, db_id, obj.id, db_id, obj.id])
				else:
					var prop_class: String = obj.get_class_name()
					code.append("var %s: %s:\n\tget: return objects.%s[&\"%s\"]" % [prop_id, prop_class, db_id, obj.id])
	
	var scr := GDScript.new()
	code = [
		"# WARNING: Autogenerated in StateBase",
		"# Allows making sure all flow_script variables and functions will work.",
		"# TODO: Show stats here, like 'lines spoken' for each character.",
		"extends StateBase"
	] + code
	scr.source_code = "\n".join(code)
	#print(scr.source_code)
	ResourceSaver.save(scr, "res://_state_.gd")
	set_script.call_deferred(load("res://_state_.gd"))
	
	Global.msg("Changing script...")

func _true_reload():
	objects = StateObjects.new()
	dbs = objects.get_dbs()
	var mods := Mods.get_enabled()
	for mod in mods:
		for prop in StateObjects.ORDER:
			var db1: Database = objects[prop]
			var db2: Database = mod[prop]
			db1.merge(db2)
	
	for db in dbs:
		db.connect_signals()
	
	Global.msg("State", "Reloaded", [objects.get_counts_string()])
	
func find_char(id: StringName) -> CharInfo: return objects.chars.find(id)
func find_item(id: StringName) -> ItemInfo: return objects.items.find(id)
func find_zone(id: StringName) -> ItemInfo: return objects.zones.find(id)
func find_equipment_slot(id: StringName) -> EquipmentSlotInfo: return objects.equipment_slots.find(id)
func find_attribute(id: StringName) -> AttributeInfo: return objects.attributes.find(id)
func find_quest(id: StringName) -> QuestInfo: return objects.quests.find(id)
	
func _get(property: StringName) -> Variant:
	for db in dbs:
		if db.has(property):
			return db.get(property)
	return null

func _set(property: StringName, value: Variant) -> bool:
	for db in dbs:
		if db.has(property):
			db.set(property, value)
			return true
	return false
