@abstract class_name StateBase extends Node
## Handles state of world in a way where non-loaded content can be set/get.

@warning_ignore("unused_signal") signal event(event: Event)

var ZONE_ENTERED := Event.new({ zone=ZoneInfo, who=CharInfo })
var ZONE_EXITED := Event.new({ zone=ZoneInfo, who=CharInfo })
var QUEST_STARTED := Event.new({ quest=QuestInfo })
var QUEST_TICKED := Event.new({ quest=QuestInfo })
var ACHIEVEMENT := Event.new({ achievement=AchievementInfo })

var TOAST := Event.new({ type=TYPE_STRING_NAME, player=TYPE_INT, data=TYPE_DICTIONARY })

@export var objects: StateObjects
var dbs: Array[Database]

var chars: CharDB:
	get: return objects.chars
var items: ItemDB:
	get: return objects.items
var zones: ZoneDB:
	get: return objects.zones
var quests: QuestDB:
	get: return objects.quests

func _init() -> void:
	# reload() calls set_script() which triggers this _init().
	# We know we are in business once we are the generated script.
	if get_script().resource_path == "res://_state_.gd":
		_true_reload()

func _ready() -> void:
	reload()

func reload():
	var mods := Mods.get_enabled()
	var vars := []
	var code := []
	
	var score := VarInfo.new()
	score.default = 0
	score.value = 0
	mods[0].vars._add("score", score)
	
	for mod: ModInfo in mods:
		# Compile conditions script.
		code.append_array(mod._script_exprs)
		code.append_array(mod._script_conds)
	
		for db_id in StateObjects.ORDER:
			var db: Database = mod[db_id]
			code.append("\n####\n## %s x%s\n####" % [db_id.to_upper(), db.size()])
			for obj in db:
				var prop_id: String = obj.id.replace("#", "__")
				if "#" in obj.id: continue
				if obj is VarInfo:
					var prop_type: String = type_string(typeof(obj.default))
					code.append("var %s: %s:\n\tget: return objects.%s[&\"%s\"].value\n\tset(v): objects.%s[&\"%s\"].value = v" % [prop_id, prop_type, db_id, obj.id, db_id, obj.id])
				else:
					var prop_class: String = obj.get_class_name()
					code.append("var %s: %s:\n\tget: return objects.%s[&\"%s\"]" % [prop_id, prop_class, db_id, obj.id])
	
	var scr := GDScript.new()
	code = [
		"# WARNING: Autogenerated in StateBase",
		"# Allows making sure all flow_script variables and functions will work.",
		"# TODO: Show stats here, like 'lines spoken' for each character.",
		"extends StateBase"
	] + code
	scr.source_code = "\n".join(code)
	ResourceSaver.save(scr, "res://_state_.gd")
	set_script.call_deferred(load("res://_state_.gd"))
	
	for db in dbs:
		db.connect_signals()
	
	Global.msg("Changing script...")

func _true_reload():
	objects = StateObjects.new()
	dbs = objects.get_dbs()
	var mods := Mods.get_enabled()
	for mod in mods:
		for prop in StateObjects.ORDER:
			var db1: Database = objects[prop]
			var db2: Database = mod[prop]
			db1.merge(db2)
	Global.msg("State", "Reloaded", [objects.get_counts_string()])
	
func find_char(id: StringName) -> CharInfo: return objects.chars.find(id)
func find_item(id: StringName) -> ItemInfo: return objects.items.find(id)
func find_zone(id: StringName) -> ItemInfo: return objects.zones.find(id)
func find_equipment_slot(id: StringName) -> EquipmentSlotInfo: return objects.equipment_slots.find(id)
func find_attribute(id: StringName) -> AttributeInfo: return objects.attributes.find(id)
func find_quest(id: StringName) -> QuestInfo: return objects.quests.find(id)

#func test_condition(condition_method: StringName) -> bool:
	#if not _conditions_script.has_method(condition_method):
		#push_error("No condition method %s." % condition_method)
		#return false
	#if condition_method in _conditions_errored:
		#push_error("Skipping %s as it has non-existing variables." % [condition_method])
		#return false
	#return _conditions_script.call(condition_method)
	
func _get(property: StringName) -> Variant:
	for db in dbs:
		if db.has(property):
			return db.get(property)
	return null

func _set(property: StringName, value: Variant) -> bool:
	for db in dbs:
		if db.has(property):
			db.set(property, value)
			return true
	return false
