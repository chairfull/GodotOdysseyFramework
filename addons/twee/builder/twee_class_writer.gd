extends RefCounted
## GDScript is created with static funcs that are used in the tween to get properties.
## This lets us "mutate" at runtime, allowing for randomization and lerping towards properties that changes since the tween was created.

static var REGEX_ROOT := RegEx.create_from_string(r'@(?=(?:[A-Za-z_]|[%~][A-Za-z_]))')
static var REGEX_NODE := RegEx.create_from_string(r'\^(?=(?:[A-Za-z_]|[%~][A-Za-z_]))')
const Token := preload("../builder/twee_tokens.gd")
const Util := preload("../resources/twee_util.gd")

var _methods: Dictionary[StringName, StringName]
var _return_methods: Dictionary[StringName, StringName]
var _properties: Dictionary[StringName, Array]
var _finished: bool = false

var scr: GDScript
var signal_args: Dictionary
var initial_state: Dictionary
var for_nodes: Dictionary

func _init():
	## !signal_args
	## ~initial_state
	## @node
	scr = GDScript.new()
	scr.source_code = "#WARNING: AUTOGENERATED - CHANGES WILL BE LOST"+\
		"\nstatic var signal_args: Dictionary"+\
		"\nstatic var initial_state: Dictionary"+\
		"\nstatic var for_nodes: Dictionary"

func finish(print_source := false) -> GDScript:
	if _finished:
		push_error("Already finished.")
		return
	var head := ""
	scr.source_code += "\n# %s" % Time.get_unix_time_from_system()
	if print_source: print(scr.source_code)
	scr.reload()
	scr.signal_args = signal_args
	scr.initial_state = initial_state
	scr.for_nodes = for_nodes
	return scr

func _rewrite_expr(expr: String, targ: Object) -> String:
	var token_re := RegEx.create_from_string(
		r'(@[A-Za-z_][A-Za-z0-9_]*|~[A-Za-z_][A-Za-z0-9_]*|[A-Za-z_][A-Za-z0-9_]*)'
	)
	var out := ""
	var pos := 0
	var L := expr.length()
	
	for m in token_re.search_all(expr):
		var s := m.get_start()
		var e := m.get_end()
		# copy between last pos and this match
		out += expr.substr(pos, s - pos)
		pos = e

		var tok := m.get_string(0)

		# skip rewrite if token is part of dotted access: either preceding non-space char is '.' OR next non-space char is '.'
		var prev_idx := s - 1
		while prev_idx >= 0 and expr.substr(prev_idx, 1) == " ":
			prev_idx -= 1
		var next_idx := e
		while next_idx < L and expr.substr(next_idx, 1) == " ":
			next_idx += 1
		var prev_is_dot := prev_idx >= 0 and expr.substr(prev_idx, 1) == "."
		var next_is_dot := next_idx < L and expr.substr(next_idx, 1) == "."

		# If it's an @ or ~ token, do their transforms regardless (they're explicit).
		if tok[0] == "@":
			out += "_root." + tok.substr(1)
			continue
		if tok[0] == "~":
			out += "initial_state[_targ]." + tok.substr(1)
			continue

		# Bare identifier handling.
		# If it's part of dotted access, leave unchanged.
		if prev_is_dot or next_is_dot:
			out += tok
			continue

		# Is this a method call? (next non-space char == '(')
		var is_method_call := (next_idx < L and expr.substr(next_idx, 1) == "(")

		# If targ has the name as a method, rewrite as _targ.name (method or property)
		if is_method_call:
			if targ and targ.has_method(tok):
				out += "_targ." + tok
			else:
				out += tok
			continue

		# Not a method call: treat as property if targ has it
		if targ and (tok in targ):
			out += "_targ." + tok
		else:
			out += tok

	# append rest
	out += expr.substr(pos)
	return out


func add_property(root: Node, targ: Object, prop: StringName, getter_expr: String, returns := true) -> Array:
	var id := "%s-%s-%s" % [root.get_instance_id(), targ.get_instance_id(), getter_expr]
	if _finished:
		return _properties[id]
	var op := Util.get_object_and_property(targ, prop)
	var true_targ: Object = op[0]
	var true_prop: String = op[1]
	if not true_targ in initial_state:
		initial_state[true_targ] = {}
	if not true_prop in initial_state[true_targ]:
		initial_state[true_targ][true_prop] = true_targ.get(true_prop)
	var method_id := add_static_func(root, true_targ, getter_expr, returns)
	var out := [true_targ, true_prop, method_id]
	_properties[id] = out
	return out

func add_static_func(root: Node, targ: Object, expr: String, returns := true) -> StringName:
	var id := StringName(expr)
	if _finished:
		if returns:
			return _return_methods[id]
		else:
			return _methods[id]
	var expr_processed := _rewrite_expr(expr, targ)
	if returns:
		if id in _return_methods:
			return _return_methods[id]
		var method_name := "_rm%s" % len(_return_methods)
		scr.source_code += "\nstatic func %s(_root: Node, _targ: Object): return %s" % [method_name, expr_processed]
		_return_methods[id] = method_name
		return method_name
	# Compiler gets annoyed if you return stuff for no reason...
	else:
		if id in _methods:
			return _methods[id]
		var method_name := "_m%s" % len(_methods)
		scr.source_code += "\nstatic func %s(_root: Node, _targ: Object): %s" % [method_name, expr_processed]
		_methods[id] = method_name
		return method_name
